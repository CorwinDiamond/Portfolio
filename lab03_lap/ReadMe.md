# 4061 Lab03 submission by diamo069
- - - -
## Lab Contents
1. **Lab Contents**
2. **makefile**
3. **bin**
4. **ls**
5. **find**
6. **grep**

Above are the different sections of this document. The first 3 sections describe the contents of this submission, how to compile the submission, and how to run the executables.

The last three sections detail the use and design of each part of lab 3.

Bellow are The file contents of this lab submission. Filenames that are crossed out are are generated by make and removed by make clean.

* **//lab03_lap/**
        - This is the main folder of the submission, all of the files are contained within

    * **ReadMe.md**
            - This is the primary documentation for the lab, you are currently reading this.	 

    * **makefile**
    				- This is the makefile used for compiling the code	 

    * **make.dat**
				    - This is a script recording of the compiling process	 

    * **ls.c**
				    - This is the source file for the ls utility, more documentation can be found in the ls section of this document.	 


    * ~~**ls.o**~~
				    - Compiled Object file used by the linker to link the executable ls while make is run.	 

    * **ls.dat**
				    - This is a script recording of using the ls function.  text color and cursor repositioning ASCII escape sequences produce extraneous chars in the script file. Copying and pasting the same output from the terminal into ls2.dat cleaned up the output.	 

    * **ls2.dat**
				    - This is the same output as ls.dat, but in a more readable format without the ASCII escape sequences visible.	 

    * **find.c**
				    - This is the source file for the find utility, more documentation can be found in the find section of this document.		 


    * ~~**find.o**~~
				    - Compiled Object file used by the linker to link the executable find while make is run.	 

    * **find.dat**
				    - This is a script recording of using the find function.  text color and cursor repositioning ASCII escape sequences produce extraneous chars in the script file. Copying and pasting the same output from the terminal into find2.dat cleaned up the output.

    * **find2.dat**
 		  	    - This is the same output as find.dat, but in a more readable format without the ASCII escape sequences visible.		 

    * **grep.c**
				    - This is the source file for the grep utility, more documentation can be found in the grep section of this document.	 


    * ~~**grep.o**~~
			    	- Compiled Object file used by the linker to link the executable grep while make is run.	 

    * **grep.dat**
			    	- This is a script recording of using the grep function.  text color and cursor repositioning ASCII escape sequences produce extraneous chars in the script file. Copying and pasting the same output from the terminal into grep2.dat cleaned up the output.	 

    * **grep2.dat**
		    	  - This is the same output as grep.dat, but in a more readable format without the ASCII escape sequences visible.	 

    * ~~**bin/**~~
			    	- This folder contains the executable files created with make for this lab

        * ~~**grep**~~
                - grep executable searches for a substring in each line of a file see the grep section of this document for more information.	 

        * ~~**find**~~
    						- find executatable searches for an exact file name.ext match in a specified directory and that directory's sub-directories. See the find section of this document for more information.	 

        * ~~**ls**~~
		    				- ls executable lists the files contained within the current directory. the view of attributes and files that start with a . can be toggled on and off. See the ls section of this document for more information

- - - -

## Makefile - compiling code

in the home folder of my lab submission, lab03_lap, run `make`.

the make folder should have the following output
```
//lab03_lap $ make
bin:       mkdir bin
ls.o:      gcc -c -Wall ls.c
find.o:    gcc -c -Wall find.c
grep.o:    gcc -c -Wall grep.c
all:       cc -Wall ls.o -o bin/ls
           cc -Wall find.o -o bin/find
           cc -Wall grep.o -o bin/grep
//lab03_lap $
```

the object files are created in the home folder while the executables are created in the bin folder.  Running `make clean` will cause the contents of bin to be deleted along with the object files.

This make file requires the gcc compiler. Most of the testing of this submission was done on CSE lab computers.
```
$ gcc --version
gcc (Ubuntu 5.4.0-6ubuntu1~16.04.5) 5.4.0 20160609
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

The makefile has the following valid targets:
* **all:**  makes everything
* **bin:**  makes the bin directory
* **ls.o:**  makes the ls object file but does not link
* **find.o:**  makes the find object file but does not link
* **grep.o:**  makes the grep object file but does not link
* **find:**  makes the find object file, and makes the bin find executable
* **ls:**  makes the find object file, and makes the bin find executable
* **grep:**  makes the find object file, and makes the bin find executable
* **clean:** deletes all object files, and the bin directory

usage is `make <target>`


**Further Example of the makefile in action in file make.dat** ASCII escape characters involved
**Further Example of the makefile in action in file make2.dat** No ASCII escape characters

- - - -

## Bin

If this folder was not included, running make will create it.

This folder contains all of the executables after running make.

Having bin as the _working directory_ will make it easier to run files, but is not required. To run a file add the prefix `./<path_to_bin>/<executable> <args...>`

Some examples:
```
//lab03_lap $ ./bin/find bin
/<path_to_bin>/bin
//lab03_lap $ cd bin
//lab03_lap/bin $ ./find bin
//lab03_lap/bin $ ./ls
grep	find	ls
//lab03_lap/bin $ ./ls -a
.	..	grep	find	ls
//lab03_lap/bin $
```
In these examples I ran find in bin to find bin, it then returned bin as a result.
next I changed the working directory to bin and ran find. because it was searching bin for bin, it could not find bin.
I then ran ls and it returned the files that do not start with a `.`
I then ran ls with the -a flag, that returned all files in the current directory

- - - -

## ls

ls is one of the most used utilities in Unix based systems. This is a simplified version of ls.

invalid input cause the following output...
```
//lab03_lap/bin $ ./ls -b

Sorry, -b is not an included option for this version of ls
Valid options are: ls -l -a

	including the -l option includes file stats with output
	including the -a option includes .* files with the output
//lab03_lap/bin $
```

**So what is correct usage of ls?**

Only two options flags are legal for use with this program. Both flags must be lowercase; however, the order of the flags for this version of the program is irrelevant. i.e. all of the following are valid when used within the bin directory. `./<path_to_bin>/ls <l and a flags>` notation is required for use outside the bin directory.
1. ./ls
2. ./ls -a
3. ./ls -a -l
4. ./ls -l
5. ./ls -l -a

The same flag shall not be used more than once.. without lines 101 and 102, the code would work, but it would be bad practice to allow such tom foolery
### The -a option
The -a flag causes all of the files to be displayed including the files that start with a `.` such as this directory `.` and the up a level directory `..`

### The -l option
The -l flag allows users to view much but not all of the file information for each viewable file in the directory. The file information that is viewable is:

1. Permission - as set by chmod
2. size in bytes - the size of the file
3. blocks - number of blocks on disk that are reserved for this file
4. block size in bytes - size of the blocks on disk for this file
5. links - number of hard links - number of other names for this file
6. serial - inodes number
7. uid - number stored for user id, not going to back reference...
8. gid - number stored for group id, not going to back reference...        
9. last modified - date and time file was last modified   
10. file name - name of file

### Examples:
```
//lab03_lap $ cd bin
//lab03_lap/bin $ ./ls -a -l
Permission size b  blocks block size links serial    uid       gid           last modified        file
-rwx------ 5       1      32768      2     31738942  569156    1328160511    12.10.2017 01:25:54  .
-rwx------ 13      33     32768      3     31524120  569156    1328160511    12.10.2017 01:25:54  ..
-rwx------ 13392   17     32768      1     32015350  569156    1328160511    12.10.2017 01:25:54  grep
-rwx------ 13592   17     32768      1     32015349  569156    1328160511    12.10.2017 01:25:54  find
-rwx------ 13504   17     32768      1     32015348  569156    1328160511    12.10.2017 01:25:54  ls
//lab03_lap/bin $ ./ls -b

Sorry, -b is not an included option for this version of ls
Valid options are: ls -l -a

	including the -l option includes file stats with output
	including the -a option includes .* files with the output
//lab03_lap/bin $
```

**Additional Sample Usage available** ls.dat is the exact script output, but because of the ASCII escape sequences, it can be hard to read. however, the text version without the escape sequences is ls2.dat

### Code Overview:
Main loads the current working directory and parses the flag inputs. If inputs are invalid, it returns an error message. After opening the working directory as a pointer, main will print the titles of the file information fields if the -l flag was raised. It then will call list_file for each file in the directory (if -a is not selected, the .* files are excluded)

list_file initializes the file_stat struct to get the information from for the -l view. If the file is an executable the text is set as green, if the file is a directory, it is set as a teal/blue color.

if the -l option was used, the files stats are displayed with the following logic.

List_file then deciphers the files permissions from right to left.

starting at column 10 using ASCII escape code `\033[<screen_text_column>G`and using the ASCII escape code `\033[2D` which moves 2 columns to the left, the permission string is output and written to the screen from right to left. The process is as follows and it is easiest to think of the number in octal or binary.

i counts which bit is being decoded.

permission%2 returns the value of the rightmost bit.

the bits meaning can be decoded with i%3

if the rightmost bit is on, print the decoded char, else print -

increment i and shift the permission number to the right by dividing by 2.
```
    octal:    7  0  0
   binary:  111000000
        i: 9876543210
      i%3: 0210210210
   binary:  111000000
   decode: drwxrwxrwx
     perm: ?rwx------
directory: drwx------
```
After all permission bits have been read, if the file is a directory, add a d in front of the permission string

The rest of the stats are then displayed nicely with escape codes

the control is returned to main for the rest of the files.

- - - -

## Find

find can be used to determine if a filename exists, even in multiplicity. If it does exist, find returns the path to that file, and the name of the file

invalid input cause the following output...
```
//lab03_lap/bin $  ./bin/find asdf asdf asdf

Sorry, asdf asdf asdf was not valid input for this version of find
Valid options are: find <filename> <starting directory> -t
	current directory is the default starting directory
	if and only if a starting directory is included,
		-t may be used to show the files and directories searched
//lab03_lap/bin $
```
This error message hints at the proper usage of find.

### <filename>
Find will look within the <starting directory> and all of its sub-folders for an exact match of the filename. The filename may not include a directory prefix such as /bin/grep. /bin/grep will not be found.

Example:
```
//lab03_lap/ $ ./bin/find find
//lab03_lap/bin/find
//lab03_lap/ $ ./bin/ls
bin/  Documentation.md	find.c	find.o	grep.c	grep.o	ls.c  ls.o  makefile  ReadMe.md
//lab03_lap/ $
```
This example shows that find ignored find.c and find.o during the search even though find is a substring of those filenames. **The filename must be an exact match!**

### <starting directory>
The starting directory can be any directory for which cd <starting directory> would work. If no starting directory is explicitly stated, it is assumed that the current directory `.` is implied.

Examples:
```
//lab03_lap/ $ ./bin/find grep.c
//lab03_lap/grep.c
//lab03_lap/ $ ./bin/find cp /bin
/bin/cp
//lab03_lap/ $ cd bin
//lab03_lap/bin/ $ ./find grep.c ..
//lab03_lap/grep.c
//lab03_lap/bin/ $ ./find cp /bin
/bin/cp
```
This example shows searching in the current folder, the computers /bin folder and the next level up folder form the current directory.

### The -t option
While not part of the Unix utility find, the -t or trace option causes the program to output the files that find compares against the filename passed as a parameter.

examples:
```
//lab03_lap $ cd bin
//lab03_lap/bin $ ./find grep
//lab03_lap/bin/grep
//lab03_lap/bin $ ./find grep -t
//lab03_lap/bin/grep
//lab03_lap/bin/find
//lab03_lap/bin/ls
//lab03_lap/bin $ ./find grep ..
//lab03_lap/bin/grep
//lab03_lap/bin $ ./find grep .. -t
//lab03_lap/ReadMe.md
//lab03_lap/ls.o
//lab03_lap/find.o
//lab03_lap/grep.c
//lab03_lap/ls.c
//lab03_lap/Documentation.md
//lab03_lap/makefile
//lab03_lap/bin
//lab03_lap/bin/grep
//lab03_lap/bin/find
//lab03_lap/bin/ls
//lab03_lap/find.c
//lab03_lap/grep.o
//lab03_lap/bin $
```
This example demonstrates how many more files are searched when the next level up folder is set as the starting directory for find.

Using -t allowed me to find bugs that my program had. Originally because of recursion and switching directories, as soon as the nested find call finished, the directory had not been changed back to the 'current directory' and caused a null pointer that caused subsequent folders in the directory not to be searched.

Additionally, I was able to determine that I had not searched all of the folders because of too many open directories and had to add code to close them and add error checking to avoid seg faults.

### Examples

**Sample Usage available** find.dat is the exact script output, but because of the ASCII escape sequences, it can be hard to read. however, the text version without the escape sequences is find2.dat

### Code Overview:

Main handles adding the default <starting directory> <.> to the passed arguments. However, it does not exclude any input. All error checking is done within the find function,

The find function opens the passed directory, and iterates through all of the files in the directory. if the file is a directory, find is called on the directory using recursion to explore all of the sub-directories. because the call happens in the middle of the for loop and change directory has global consequences, find must ensure that the correct directory is open, and the pointer is pointing at the current file. For each file, checkoutFile is called.

checkoutFile compares the current file against the passed in filename.  If trace is on, all path/files sets are displayed, otherwise just matches are displayed. If the file is a directory, checkoutFile calls find on that directory.

- - - -

## Grep

Grep searches a file for a substring and echoes every line the substring is found on.

### Usage: ./grep <string> <filename>
```
//lab03_lap $ ./bin/grep blah blah blah

Sorry, blah blah blah was not valid input for this version of grep
Valid options are: grep <string> <filename>

	string is literal, only exact string matches, no wildcards
	string must contained within a line,
		it will be ignored if text is wrapped to next line
	filename must be valid
	blah was not found in blah
//lab03_lap $
```
The string input may not have wild cards. if the exact string is a substring of a line in the file, the file number will be returned with the substring highlighted in the text

If the string file can not be found or opened, an error will be returned.

If the substring is not found, the following message will be displayed
```
//lab03_lap $ ./bin/grep <string> <valid file>
	<string> was not found in <valid file>
```
### Examples
```
//lab03_lap $ ./bin/grep grep grep.c
     5:     Purpose:  This program replicates the grep utility in Unix based systems
     6:     Usage:   ./grep <string><file>
    34:   printf(" was not valid input for this version of grep\e[m");
    35:   printf("\n\e[mValid options are: grep");
    54:             printf("\n\e[mValid options are: grep");
//lab03_lap $ ./bin/grep grepy grep.c
	grepy was not found in grep.c
//lab03_lap $ ./bin/grep grepy grepy.c
ERROR: Unable to open file: grepy.c

	file() error on grepy.c: No such file or directory

Valid options are: grep <string> <filename>

	string is literal, only exact string matches, no wildcards
	string must contained within a line
		it will be ignored if text is wrapped to next line
	filename must be valid
	grepy was not found in grepy.c
//lab03_lap $
```
These examples show the program working properly in the first call. The second call shows the file did not contain the string, and the third call uses an invalid file.

**Sample Usage available** grep.dat is the exact script output, but because of the ASCII escape sequences, it can be hard to read. however, the text version without the escape sequences is grep2.dat

### Code Overview:
Main calls openfile() to open the file, it then checks if the substring exists.
lines 88 - 113 could be replaced with printf("%s", current_line); but it would not have the cool highlighted substrings.

the way the substrings get highlighted is as follows.
```
for each char in string current_line
  if start of substring
    check if next n chars match substring...
    if found substring
      color flag set to n so n next chars are colored
  if color flag > 0
    set text color
    flag--
  print next char
  reset text color
```
